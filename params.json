{
  "name": "Property Lazy Injection",
  "tagline": "IoC属性延迟注入解决思路",
  "body": "##延迟注入(Lazy Injection)\r\n```\r\n在属性注入中，让属性注入的时机发生在我们首次使用属性时\r\n即被注入的属性第一次在使用前都为null来提高性能和节约内存\r\n我把这个方式叫做——\"延迟注入(Lazy Injection)\"\r\n```\r\n在我们的简易IoC Container中，提供了一个特性 InjectionAttribute\r\n```cs\r\n[AttributeUsage(AttributeTargets.Property , AllowMultiple = false)]\r\npublic class InjectionAttribute : Attribute\r\n{\r\n    public bool Lazy { get; set; }\r\n}\r\n```\r\n为虚属性标记Injection并把Lazy设置为true来启动延迟注入，例如：\r\n```cs\r\npublic class FooService : IFooService\r\n{\r\n    [Injection(Lazy = true)]\r\n    public virtual ILogger Logger { get; set; }\r\n    \r\n    public FooService()\r\n    {\r\n    }\r\n}\r\n```\r\nLogger实现ILogger接口，并在构造器中打印\"Logger is creating ..\"\r\n```cs\r\npublic class Logger : ILogger\r\n{\r\n    public Logger()\r\n    {\r\n        Console.WriteLine(\"Logger is creating ..\");\r\n    }\r\n}\r\n```\r\n测试代码：\r\n```cs\r\n[TestMethod]\r\npublic void LazyInjection_Test()\r\n{\r\n    Container container = new Container();\r\n    container.Register<ILogger , Logger>();\r\n    container.Register<IFooService , FooService>();\r\n    var foo = container.Resolve<IFooService>();\r\n    Console.WriteLine(\"IFooService is created\");\r\n    Console.WriteLine(\"Logger is not create\");\r\n    var logger = foo.Logger;           \r\n    Console.WriteLine(\"Logger is created\");\r\n    var logger2 = foo.Logger;\r\n}\r\n```\r\n输出：\r\n```\t\t\r\nIFooService is created\r\nLogger is not create\r\nLogger is creating ..\r\nLogger is created\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}